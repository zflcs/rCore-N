.globl __push_trace
.attribute arch, "rv64imac"
# event_id in a0
__push_trace:
    # prologue
    addi sp, sp, -16
    sd t0, 0*8(sp)
    sd t1, 1*8(sp)

    li t0, 0x101000000 # MEMORY_END
    li t1, 2*8
    amoadd.d t1, t1, (t0) # t2 <- queue_tail, queue_tail <- queue_tail + 16
    slli t0, tp, 32
    or a0, a0, t0
    slli t0, gp, 36
    or a0, a0, t0
    sd a0, 0*8(t1)
    csrr a0, cycle
    sd a0, 1*8(t1)

    # epilogue
    ld t1, 1*8(sp)
    ld t0, 0*8(sp)
    addi sp, sp, 16

# 这段RISC-V汇编代码演示了一些基本的指令和操作，包括立即数加载、原子操作、位操作和系统寄存器访问。下面是对每条指令的解释：
#
# 1. `li t0, 0x101000000 # MEMORY_END`
#    - `li` 指令用于将立即数加载到寄存器中。这里将立即数 `0x101000000` 加载到寄存器 `t0` 中。注释 `# MEMORY_END` 表明这个值可能表示某个内存区域的结束地址。
#
# 2. `li t1, 2*8`
#    - 同样使用 `li` 指令将 `2*8` 的结果（即16）加载到寄存器 `t1` 中。
#
# 3. `amoadd.d t1, t1, (t0) # t2 <- queue_tail, queue_tail <- queue_tail + 16`
#    - `amoadd.d` 是一个原子操作指令，用于对双字（64位）进行原子累加操作。这里将 `t1` 寄存器的值与 `t0` 指向的内存地址中的值相加，并将结果存储在 `t1` 中，同时内存地址中的值也更新为新的结果。注释中的 `t2 <- queue_tail, queue_tail <- queue_tail + 16` 可能是对操作的描述，但在这个指令中并没有直接使用 `t2` 寄存器。
#
# 4. `slli t0, tp, 32`
#    - `slli` 指令将 `tp` 寄存器的值逻辑左移32位，并将结果存储在 `t0` 中。
#
# 5. `or a0, a0, t0`
#    - `or` 指令将 `a0` 和 `t0` 寄存器的值进行按位或操作，并将结果存储在 `a0` 中。
#
# 6. `slli t0, gp, 36`
#    - 再次使用 `slli` 指令将 `gp` 寄存器的值逻辑左移36位，并将结果存储在 `t0` 中。
#
# 7. `or a0, a0, t0`
#    - 又一次使用 `or` 指令将 `a0` 和 `t0` 寄存器的值进行按位或操作，并将结果存储在 `a0` 中。
#
# 8. `sd a0, 0*8(t1)`
#    - `sd` 指令将 `a0` 寄存器的值存储到 `t1` 寄存器指定的内存地址中。这里 `0*8` 表示偏移量是0，所以 `a0` 的值将被存储在 `t1` 指向的地址。
#
# 9. `csrr a0, cycle`
#    - `csrr` 指令用于读取系统寄存器的值。这里读取的是 `cycle` 寄存器，它通常用于返回系统周期计数器的值，并将这个值存储在 `a0` 中。
#
# 10. `sd a0, 1*8(t1)`
#     - 最后，再次使用 `sd` 指令将 `a0` 寄存器的值存储到 `t1` 寄存器指定的内存地址加上8字节偏移的位置。
#
# 这段代码可能是在进行某种形式的内存分配或同步操作，其中涉及到对特定内存地址的更新和对系统时间戳的记录。使用原子操作确保了在多处理器环境中操作的一致性。
#
#   在RISC-V汇编语言中，括号`()`和无括号的寄存器表示方法有不同含义：
#
# - **无括号**：当使用无括号的寄存器表示，如`t0`，它通常表示直接使用寄存器中的值。
#
# - **有括号**：当使用括号括起来的寄存器表示，如`(t0)`，这通常表示间接寻址，即获取寄存器`t0`中存储的地址，并访问该地址处的内存值。
#
# 具体到RISC-V汇编指令中：
#
# - **直接寻址**：使用寄存器`t0`作为操作数，例如`add t1, t0, x0`，这里`t0`的值将直接参与运算。
#
# - **间接寻址**：使用寄存器`t0`中的地址来访问内存，例如`lw a0, (t0)`，这里`lw`（load word）指令将从`t0`指向的内存地址加载一个词到寄存器`a0`。
#
# 在提供的代码片段中：
#
# ```assembly
# amoadd.d t1, t1, (t0) # t2 <- queue_tail, queue_tail <- queue_tail + 16
# ```
# `amoadd.d` 指令是一个原子操作，它需要一个内存地址作为目标。`(t0)` 表示`t0`寄存器中存储的地址，`amoadd.d` 将对这个地址进行原子累加操作。这条指令的意思是将`t1`的值与`t0`指向的内存地址中的值相加，并将结果存储回内存地址中，同时更新`t1`的值为新的结果。
#
# 总结来说，`(t0)`与`t0`的区别在于：
# - `t0`：表示寄存器`t0`中的值。
# - `(t0)`：表示以寄存器`t0`中的值为地址的内存位置。

