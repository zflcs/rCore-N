use alloc::collections::LinkedList;

use crate::{SigInfo, SigSet};

/// The set of signals that are pending for delivery to the thread.
///
/// A signal may be blocked, which means that it will not be delivered until
/// it is later unblocked. Between the time when it is generated and when it
/// is delivered a signal is said to be pending.
///
/// Each thread in a process has an independent signal mask, which indicates
/// the set of signals that the thread is currently blocking. A thread can
/// manipulate its signal mask using pthread_sigmask(3). In a traditional
/// single-threaded application, sigprocmask(2) can be used to manipulate the
/// signal mask.
///
/// A child created via fork(2) inherits a copy of its parent's signal mask;
/// the signal mask is preserved across execve(2).
///
/// A signal may be process-directed or thread-directed. A process-directed
/// signal is one that is targeted at (and thus pending for) the process as a whole.
/// A signal may be process-directed because it was generated by the kernel for
/// reasons other than a hardware exception, or because it was sent using kill(2)
/// or sigqueue(3). A thread-directed signal is one that is targeted at a specific
/// thread. A signal may be thread-directed because it was generated as a consequence
/// of executing a specific machine-language instruction that triggered a hardware
/// exception (e.g., SIGSEGV for an invalid memory access, or SIGFPE for a math error),
/// or because it was targeted at a specific thread using interfaces such as tgkill(2)
/// or pthread_kill(3).
///
/// A process-directed signal may be delivered to any one of the threads that does
/// not currently have the signal blocked. If more than one of the threads has the
/// signal unblocked, then the kernel chooses an arbitrary thread to which to deliver
/// the signal.
///
/// A thread can obtain the set of signals that it currently has pending using
/// sigpending(2).  This set will consist of the union of the set of pending
/// process-directed signals and the set of signals pending for the calling thread.
///
/// A child created via fork(2) initially has an empty pending signal set; the pending
/// signal set is preserved across an execve(2).
#[derive(Debug, Default)]
pub struct SigPending {
    /// Pending signals will be added to this list.
    pub list: LinkedList<SigInfo>,

    /// A mask for current pending signals.
    pub mask: SigSet,
}

impl SigPending {
    /// Creates a new `SigPending`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Outstanding pending unblocked signals.
    pub fn is_pending(&self) -> bool {
        !self.mask.is_empty()
    }

    /// Adds a `SigInfo` to the pending list.
    ///
    /// Result is unpredictable if `signum` is out of range.
    pub fn add(&mut self, sig: SigInfo) {
        self.list.push_back(sig);
        self.mask.set(sig.signo as usize - 1);
    }

    /// Fetches a pending unblocked signal to handle.
    pub fn fetch(&mut self) -> Option<SigInfo> {
        // Finds a signal to handle.
        let mut siginfo = None;
        let mut first = 0;
        for (i, sig) in self.list.iter().enumerate() {
            if self.mask.get(sig.signo as usize - 1) {
                siginfo = Some(*sig);
                first = i;
                break;
            }
        }
        // Removes the signal from pending list.
        if siginfo.is_some() {
            self.list.remove(first);
            self.mask.unset(siginfo.unwrap().signo as usize - 1);
        }
        siginfo
    }
}
